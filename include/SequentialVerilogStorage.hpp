#pragma once
#include <CircuitGenGraph/GraphUtils.hpp>
#include <string_view>
#include <unordered_map>
namespace SequentialVerilogInstance {
using namespace CG_Graph;
static std::unordered_map<SequentialTypes, std::string_view> SequentialTypeToVerilog = { 
    {affr, "\t// RST signal \"first\" - when it is in a logical zero state, trigger writes logical zero to the output\n"
	"\t// RST signal \"first\" is async - always block enables on negedge of RST\n"
	"\talways @(posedge clk or negedge first) begin\n"
	"\t\tif (!first) _0 <= 1'b0;\n"
	"\t\t\telse _0 <= data;\n"
	"\tend\n"}, { affre, "\t// RST signal \"second\" - when it is in a logical zero state, trigger writes logical zero to the output\n"
	"\t// RST signal \"second\" is async - always block enables on negedge of RST\n"
	"\t// EN signal \"first\" - when it is in a logical one state, trigger writes data to the output\n"
	"\talways @(posedge clk or negedge second) begin\n"
		"\t\tif (!second) _1 <= 1'b0;\n"
		"\t\telse if (first) _1 <= data;\n"
	"\tend\n"}, { affrs, 	"\t// RST signal \"first\" - when it is in a logical zero state, trigger writes logical zero to the output\n"
	"\t// RST signal \"first\" is async - always block enables on negedge of RST\n"
	"\t// SET signal \"second\" - when it is in a logical one state, trigger writes logical one to the output\n"
	"\talways @(posedge clk or negedge first) begin\n"
		"\t\tif (!first) _2 <= 1'b0;\n"
		"\t\telse if (second) _2 <= 1'b1;\n"
		"\t\telse _2 <= data;\n"
	"\tend\n"}, { affrse, "\t// RST signal \"first\" - when it is in a logical zero state, trigger writes logical zero to the output\n"
	"\t// RST signal \"first\" is async - always block enables on negedge of RST\n"
	"\t// SET signal \"second\" - when it is in a logical one state, trigger writes logical one to the output\n"
	"\t// EN signal \"third\" - when it is in a logical one state, trigger writes data to the output\n"
	"\talways @(posedge clk or negedge first) begin\n"
		"\t\tif (!first) _3 <= 1'b0;\n"
		"\t\telse if (second) _3 <= 1'b1;\n"
		"\t\telse if (third) _3 <= data;\n"
	"\tend\n"}, {
        latch, "\t// EN signal \"clk\" - when it is in a logical one state, trigger writes data to the output\n"
	"\talways @(*) begin\n"
		"\t\telse if (clk) _4 <= data;\n"
    },    
    {
      latchr, "\t// RST signal \"first\" - when it is in a logical zero state, trigger writes logical zero to the output\n"
	"\t// EN signal \"clk\" - when it is in a logical one state, trigger writes data to the output\n"
	"\talways @(*) begin\n"
		"\t\tif (!first) _4 <= 1'b0;\n"
		"\t\telse if (clk) _4 <= data;\n"
	"\tend\n"}, { latchc, 	"\t// CLR signal \"first\" - when it is in a logical one state, trigger writes logical zero to the output\n"
	"\t// EN signal \"clk\" - when it is in a logical one state, trigger writes data to the output\n"
	"\talways @(*) begin\n"
		"\t\tif (first) _5 <= 1'b0;\n"
		"\t\telse if (clk) _5 <= data;\n"
	"\tend\n"}, { latchs, "\t// SET signal \"first\" - when it is in a logical one state, trigger writes logical one to the output\n"
	"\t// EN signal \"clk\" - when it is in a logical one state, trigger writes data to the output\n"
	"\talways @(*) begin\n"
		"\t\tif (first) _6 <= 1'b1;\n"
		"\t\telse if (clk) _6 <= data;\n"
	"\tend\n"}, {
      latchrs, "\t// RST signal \"first\" - when it is in a logical zero state, trigger writes logical zero to the output\n"
	"\t// SET signal \"second\" - when it is in a logical one state, trigger writes logical one to the output\n"
	"\t// EN signal \"clk\" - when it is in a logical one state, trigger writes data to the output\n"
	"\talways @(*) begin\n"
		"\t\tif (!first) _7 <= 1'b0;\n"
		"\t\telse if (second) _7 <= 1'b1;\n"
		"\t\telse if (clk) _7 <= data;\n"
	"\tend\n"}, { latchcs, "\t// CLR signal \"first\" - when it is in a logical one state, trigger writes logical zero to the output\n"
	"\t// SET signal \"second\" - when it is in a logical one state, trigger writes logical one to the output\n"
	"\t// EN signal \"clk\" - when it is in a logical one state, trigger writes data to the output\n"
	"\talways @(*) begin\n"
		"\t\tif (first) _8 <= 1'b0;\n"
		"\t\telse if (second) _8 <= 1'b1;\n"
		"\t\telse if (clk) _8 <= data;\n"
	"\tend\n"},{ff, "\talways @(posedge clk) begin\n"
		"\t\t_20 <= data;\n"}, { ffe, "\t// EN signal \"first\" - when it is in a logical one state, trigger writes data to the output\n"
	"\talways @(posedge clk) begin\n"
		"\t\tif (first) _9 <= data;\n"
	"\tend\n"}, { ffr, "\t// RST signal \"first\" - when it is in a logical zero state, trigger writes logical zero to the output\n"
	"\talways @(posedge clk) begin\n"
		"\t\tif (!first) _10 <= 1'b0;\n"
		"\t\telse _10 <= data;\n"
	"\tend\n"}, { ffc, "\t// CLR signal \"first\" - when it is in a logical one state, trigger writes logical zero to the output\n"
	"\talways @(posedge clk) begin\n"
		"\t\tif (first) _11 <= 1'b0;\n"
		"\t\telse _11 <= data;\n"
	"\tend\n"}, { SequentialTypes::ffs, "\t// SET signal \"first\" - when it is in a logical one state, trigger writes logical one to the output\n"
	"\talways @(posedge clk) begin\n"
		"\t\tif (first) _12 <= 1'b1;\n"
		"\t\telse _12 <= data;\n"
	"\tend\n"}, { ffre, "\t// RST signal \"second\" - when it is in a logical zero state, trigger writes logical zero to the output\n"
	"\t// EN signal \"first\" - when it is in a logical one state, trigger writes data to the output\n"
	"\talways @(posedge clk) begin\n"
		"\t\tif (!second) _13 <= 1'b0;\n"
		"\t\telse if (first) _13 <= data;\n"
	"\tend\n"}, { ffce, "\t// CLR signal \"second\" - when it is in a logical one state, trigger writes logical zero to the output\n"
	"\t// EN signal \"first\" - when it is in a logical one state, trigger writes data to the output\n"
	"\talways @(posedge clk) begin\n"
		"\t\tif (second) _14 <= 1'b0;\n"
		"\t\telse if (first) _14 <= data;\n"
	"\tend\n"}, { ffse, "\t// SET signal \"second\" - when it is in a logical one state, trigger writes logical one to the output\n"
	"\t// EN signal \"first\" - when it is in a logical one state, trigger writes data to the output\n"
	"\talways @(posedge clk) begin\n"
		"\t\tif (second) _15 <= 1'b1;\n"
		"\t\telse if (first) _15 <= data;\n"
	"\tend\n"}, {
      ffrs, "\t// RST signal \"first\" - when it is in a logical zero state, trigger writes logical zero to the output\n"
	"\t// SET signal \"second\" - when it is in a logical one state, trigger writes logical one to the output\n"
	"\talways @(posedge clk) begin\n"
		"\t\tif (!first) _16 <= 1'b0;\n"
		"\t\telse if (second) _16 <= 1'b1;\n"
		"\t\telse _16 <= data;\n"
	"\tend\n"}, { ffcs, "\t// CLR signal \"first\" - when it is in a logical one state, trigger writes logical zero to the output\n"
	"\t// SET signal \"second\" - when it is in a logical one state, trigger writes logical one to the output\n"
	"\talways @(posedge clk) begin\n"
		"\t\tif (first) _17 <= 1'b0;\n"
		"\t\telse if (second) _17 <= 1'b1;\n"
		"\t\telse _17 <= data;\n"
	"\tend\n"}, { ffrse, "\t// RST signal \"first\" - when it is in a logical zero state, trigger writes logical zero to the output\n"
	"\t// SET signal \"second\" - when it is in a logical one state, trigger writes logical one to the output\n"
	"\t// EN signal \"third\" - when it is in a logical one state, trigger writes data to the output\n"
	"\talways @(posedge clk) begin\n"
		"\t\tif (!first) _18 <= 1'b0;\n"
		"\t\telse if (second) _18 <= 1'b1;\n"
		"\t\telse if (third) _18 <= data;\n"
	"\tend\n"}, { ffcse, "\t// CLR signal \"first\" - when it is in a logical one state, trigger writes logical zero to the output\n"
	"\t// SET signal \"second\" - when it is in a logical one state, trigger writes logical one to the output\n"
	"\t// EN signal \"third\" - when it is in a logical one state, trigger writes data to the output\n"
	"\talways @(posedge clk) begin\n"
		"\t\tif (first) _19 <= 1'b0;\n"
		"\t\telse if (second) _19 <= 1'b1;\n"
		"\t\telse if (third) _19 <= data;\n"
	"\tend\n"}, { nff, "\talways @(negedge clk) begin\n"
		"\t\t_20 <= data;\n"
	"\tend\n"}, { nffe, "\t// EN signal \"first\" - when it is in a logical one state, trigger writes data to the output\n"
	"\talways @(negedge clk) begin\n"
		"\t\tif (first) _21 <= data;\n"
	"\tend\n"}, { nffr, "\t// RST signal \"first\" - when it is in a logical zero state, trigger writes logical zero to the output\n"
	"\talways @(negedge clk) begin\n"
		"\t\tif (!first) _22 <= 1'b0;\n"
		"\t\telse _22 <= data;\n"
	"\tend\n"}, { nffc, "\t// CLR signal \"first\" - when it is in a logical one state, trigger writes logical zero to the output\n"
	"\talways @(negedge clk) begin\n"
		"\t\tif (first) _23 <= 1'b0;\n"
		"\t\telse _23 <= data;\n"
	"\tend\n"}, { SequentialTypes::nffs, "\t// SET signal \"first\" - when it is in a logical one state, trigger writes logical one to the output\n"
	"\talways @(negedge clk) begin\n"
		"\t\tif (first) _24 <= 1'b1;\n"
		"\t\telse _24 <= data;\n"
	"\tend\n"}, {
      nffre, "\t// RST signal \"second\" - when it is in a logical zero state, trigger writes logical zero to the output\n"
	"\t// EN signal \"first\" - when it is in a logical one state, trigger writes data to the output\n"
	"\talways @(negedge clk) begin\n"
		"\t\tif (!second) _25 <= 1'b0;\n"
		"\t\telse if (first) _25 <= data;\n"
	"\tend\n"}, { nffce, "\t// CLR signal \"second\" - when it is in a logical one state, trigger writes logical zero to the output\n"
	"\t// EN signal \"first\" - when it is in a logical one state, trigger writes data to the output\n"
	"\talways @(negedge clk) begin\n"
		"\t\tif (second) _26 <= 1'b0;\n"
		"\t\telse if (first) _26 <= data;\n"
	"\tend\n"}, { nffse, "\t// SET signal \"second\" - when it is in a logical one state, trigger writes logical one to the output\n"
	"\t// EN signal \"first\" - when it is in a logical one state, trigger writes data to the output\n"
	"\talways @(negedge clk) begin\n"
		"\t\tif (second) _27 <= 1'b1;\n"
		"\t\telse if (first) _27 <= data;\n"
	"\tend\n"}, { nffrs, "\t// RST signal \"first\" - when it is in a logical zero state, trigger writes logical zero to the output\n"
	"\t// SET signal \"second\" - when it is in a logical one state, trigger writes logical one to the output\n"
	"\talways @(negedge clk) begin\n"
		"\t\tif (!first) _28 <= 1'b0;\n"
		"\t\telse if (second) _28 <= 1'b1;\n"
		"\t\telse _28 <= data;\n"
	"\tend\n"}, { nffcs, "\t// CLR signal \"first\" - when it is in a logical one state, trigger writes logical zero to the output\n"
	"\t// SET signal \"second\" - when it is in a logical one state, trigger writes logical one to the output\n"
	"\talways @(negedge clk) begin\n"
		"\t\tif (first) _29 <= 1'b0;\n"
		"\t\telse if (second) _29 <= 1'b1;\n"
		"\t\telse _29 <= data;\n"
	"\tend\n"}, { nffrse, "\t// RST signal \"first\" - when it is in a logical zero state, trigger writes logical zero to the output\n"
	"\t// SET signal \"second\" - when it is in a logical one state, trigger writes logical one to the output\n"
	"\t// EN signal \"third\" - when it is in a logical one state, trigger writes data to the output\n"
	"\talways @(negedge clk) begin\n"
		"\t\tif (!first) _30 <= 1'b0;\n"
		"\t\telse if (second) _30 <= 1'b1;\n"
		"\t\telse if (third) _30 <= data;\n"
	"\tend\n"}, { nffcse, "\t// CLR signal \"first\" - when it is in a logical one state, trigger writes logical zero to the output\n"
	"\t// SET signal \"second\" - when it is in a logical one state, trigger writes logical one to the output\n"
	"\t// EN signal \"third\" - when it is in a logical one state, trigger writes data to the output\n"
	"\talways @(negedge clk) begin\n"
		"\t\tif (first) _31 <= 1'b0;\n"
		"\t\telse if (second) _31 <= 1'b1;\n"
		"\t\telse if (third) _31 <= data;\n"
	"\tend\n"}, { naffrs, "\t// RST signal \"first\" - when it is in a logical zero state, trigger writes logical zero to the output\n"
	"\t// RST signal \"first\" is async - always block enables on negedge of RST\n"
	"\t// SET signal \"second\" - when it is in a logical one state, trigger writes logical one to the output\n"
	"\talways @(negedge clk or negedge first) begin\n"
		"\t\tif (!first) _32 <= 1'b0;\n"
		"\t\telse if (second) _32 <= 1'b1;\n"
		"\t\telse _32 <= data;\n"
	"\tend\n"}, { naffrse, "\t// RST signal \"first\" - when it is in a logical zero state, trigger writes logical zero to the output\n"
	"\t// RST signal \"first\" is async - always block enables on negedge of RST\n"
	"\t// SET signal \"second\" - when it is in a logical one state, trigger writes logical one to the output\n"
	"\t// EN signal \"third\" - when it is in a logical one state, trigger writes data to the output\n"
	"\talways @(negedge clk or negedge first) begin\n"
		"\t\tif (!first) _33 <= 1'b0;\n"
		"\t\telse if (second) _33 <= 1'b1;\n"
		"\t\telse if (third) _33 <= data;\n"
	"\tend\n"}, { naffr, "\t// RST signal \"first\" - when it is in a logical zero state, trigger writes logical zero to the output\n"
	"\t// RST signal \"first\" is async - always block enables on negedge of RST\n"
	"\talways @(negedge clk or negedge first) begin\n"
		"\t\tif (!first) _34 <= 1'b0;\n"
		"\t\telse _34 <= data;\n"
	"\tend\n"
}, {
      naffre,"\t// RST signal \"first\" - when it is in a logical zero state, trigger writes logical zero to the output\n"
	"\t// RST signal \"first\" is async - always block enables on negedge of RST\n"
    "\t// EN signal \"second\" - when it is in a logical one state, trigger writes data to the output\n"
	"\talways @(negedge clk or negedge first) begin\n"
		"\t\tif (!first) _34 <= 1'b0;\n"
		"\t\telse _34 <= data;\n"
        "\t\telse if (third) _34 <= data;\n"
	"\tend\n"}
};
} // namespace SequentialVerilogInstance