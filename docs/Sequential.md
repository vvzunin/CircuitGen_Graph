# Последовательностная логика
Для поддержки последовательностной логики в граф были добавлены вершины типа `Sequential`. Для указания типа последовательностной логики, которую они реализуют, был добавлен следующий набор флагов:
* EN = 1
* SET = 2
* CLR = 4
* RST = 8
* ASYNC = 32
* NEGEDGE = 64
* ff = 16
* latch = 1

Отметим, что фактически флаг `latch` является псеводнимом для флага `EN`, так как данная ячейка обяза иметь флаг разрешения записи. Кроме того, данная ячейка не может иметь тактового сигнала (в силу того, что она чувствительна ко всем сигналам в целом). Не допускается одновременное использование флагов `RST` и `CLR`.

Прочие типы формируются засчет битовых операций между данными типами. Каждое значение является какой-либо степенью двойки. `latch` не может иметь флаги `ASYNC`, `NEGEDGE`.

Именование типов строится следующим образом - в имя элемента enum добавляется первая буква соответствующего флага, который используется в данном элементе. При наличии флагов `ASYNC` и `NEGEDGE` соответствующая буква ставится до имени самого используемого типа триггера (до `ff`, например, `nff`). Сначала ставится `n`, отвечающая за `negedge` для тактирующего сигнала, после, при наличии, `a` для обозначения наличия асинхронного сброса. Последний относится к сигналу `RST` и может быть использован только в связке с ним.

Порядок букв в имени типа важен. Так, для сигнала `nffre` (_flif-flop with negedge clock signal, reset sync signal and enable signal_ ) после передачи, собственно, тактирующего сигнала и сигнала, данные из которого буду писаться в регистр, требуется передать сигнал `RST` и `EN` именно в этом порядке. В случае, если, скажем, указать тип, ожидающий больше/меньше сигналов, чем было передано, то в поток ошибок (или в поток для логирования ошибок, если  включено логирование) будет выведено предупреждение о том, что сигнал для определенного флага не был получен (с указанием флага).

Полный список существующих типов вы можете найти в файле `GraphUtils.hpp` в директории `include/CircuitGenGraph`. Максимальное число сигналов, которые можно передать в конструктор типа для типа `GraphVertexSequential` - 5, а именно тактовый сигнал, сигнал, подаваемый на вход, сигнал сброса, сигнал установки логической единицы, сигнал разрешения записи. Данный конструктор, в отличие от прочих, принимающих меньшее число сигналов (вплоть до 2 сигналов, тактовый сигнал/сигнал разрешения записи для `latch`, и сигнал, подаваемый на вход), может создавать только `ff`.

Пример создания ячейки с асинхронным сигналом сброса и сигналом разрешения записи:

```
GraphPtr graph = std::make_shared<OrientedGraph>();

auto *clk = graph->addInput("clk");
auto *data = graph->addInput("data");
auto *rst_n = graph->addInput("rst_n");
auto *en = graph->addInput("en");
auto *seq = graph->addSequential(affre, clk, data, rst_n, en, "q");

auto *out = graph->addOutput("res");
graph->addEdge(seq, out);

graph->toVerilog("./", "example.v");

```

Получаемый Verilog-код:

```
module graph_0(
    clk, data, rst_n, en, 
    res
);
    // Writing inputs
    input clk, data, rst_n, en;
    // Writing outputs
    output res;
    // Writing registers
    reg q;

    // RST signal \rst_n\ - when it is in a logical zero state, trigger writes logical zero to the output
    // RST signal \rst_n\ is async - always block enables on negedge of RST
    // EN signal \en\ - when it is in a logical one state, trigger writes data to the output
    always @(posedge clk or negedge rst_n) begin
        if (!rst_n) q <= 1'b0;
        else if (en) q <= data;
    end

    assign res = q;
endmodule
```
